{"ast":null,"code":"import { __decorate } from \"tslib\";\nimport { Component } from '@angular/core';\nexport let DopplerRangeComponent = class DopplerRangeComponent {\n  constructor(dataService) {\n    this.dataService = dataService;\n    this.dopplerData = null;\n    this.currentFrame = [];\n    this.heatmapCells = [];\n    this.maxValue = 0;\n    this.minValue = 0;\n    // Animation properties (come LivePlot_class.py)\n    this.currentFrameIndex = 0;\n    this.totalFrames = 0;\n    this.isAnimating = false;\n    this.animationInterval = null;\n    this.animationSpeed = 100; // 100ms come nel LivePlot_class.py\n    // Grid dimensions\n    this.rows = 0;\n    this.cols = 0;\n  }\n  ngOnInit() {\n    this.fetchDopplerData();\n  }\n  ngOnDestroy() {\n    this.stopAnimation();\n  }\n  fetchDopplerData() {\n    console.log('Fetching Range-Doppler Map data...');\n    this.dataService.getDoppler().subscribe({\n      next: data => {\n        console.log('Range-Doppler Map data received:', data);\n        this.dopplerData = data;\n        this.initializeData();\n      },\n      error: error => {\n        console.error('Error fetching Range-Doppler data:', error);\n      }\n    });\n  }\n  initializeData() {\n    if (!this.dopplerData || !this.dopplerData['Range-Doppler Map']) {\n      console.error('Invalid Range-Doppler Map data');\n      return;\n    }\n    const rangeData = this.dopplerData['Range-Doppler Map'];\n    this.totalFrames = rangeData.length;\n    console.log('Total frames:', this.totalFrames);\n    if (this.totalFrames > 0) {\n      // Dimensioni originali\n      const originalRows = rangeData[0].length;\n      const originalCols = rangeData[0][0].length;\n      // Dopo la trasposizione, le dimensioni si scambiano\n      this.rows = originalCols; // Le colonne diventano righe\n      this.cols = originalRows; // Le righe diventano colonne\n      console.log('Original dimensions:', originalRows, 'x', originalCols);\n      console.log('Transposed dimensions:', this.rows, 'x', this.cols);\n      // Calcola min/max su tutti i frame\n      this.calculateGlobalMinMax();\n      console.log('Value range:', this.minValue, 'to', this.maxValue);\n      // Mostra il primo frame\n      this.currentFrameIndex = 0;\n      this.showFrame(this.currentFrameIndex);\n    }\n  }\n  calculateGlobalMinMax() {\n    const allValues = [];\n    this.dopplerData['Range-Doppler Map'].forEach(frame => {\n      frame.forEach(row => {\n        allValues.push(...row);\n      });\n    });\n    this.maxValue = Math.max(...allValues);\n    this.minValue = Math.min(...allValues);\n    console.log('Sample values:', allValues.slice(0, 10)); // Mostra i primi 10 valori\n  }\n\n  showFrame(frameIndex) {\n    if (!this.dopplerData || frameIndex >= this.totalFrames) return;\n    // Ottieni il frame originale\n    let frame = this.dopplerData['Range-Doppler Map'][frameIndex];\n    // Applica la trasposizione per ruotare di 90 gradi\n    this.currentFrame = this.transposeMatrix(frame);\n    this.generateHeatmapCells();\n  }\n  // Funzione per trasporre una matrice (ruota di 90 gradi)\n  transposeMatrix(matrix) {\n    if (!matrix || matrix.length === 0) return matrix;\n    const rows = matrix.length;\n    const cols = matrix[0].length;\n    const transposed = [];\n    // Crea la matrice trasposta: [i][j] diventa [j][i]\n    for (let j = 0; j < cols; j++) {\n      transposed[j] = [];\n      for (let i = 0; i < rows; i++) {\n        transposed[j][i] = matrix[i][j];\n      }\n    }\n    return transposed;\n  }\n  // Metodi di controllo animazione (come LivePlot_class.py)\n  startAnimation() {\n    if (this.isAnimating) return;\n    this.isAnimating = true;\n    this.currentFrameIndex = 0;\n    this.animationInterval = setInterval(() => {\n      this.updateFrame();\n    }, this.animationSpeed);\n  }\n  stopAnimation() {\n    this.isAnimating = false;\n    if (this.animationInterval) {\n      clearInterval(this.animationInterval);\n      this.animationInterval = null;\n    }\n  }\n  updateFrame() {\n    if (this.currentFrameIndex < this.totalFrames) {\n      this.showFrame(this.currentFrameIndex);\n      console.log(`Frame: ${this.currentFrameIndex}`);\n      this.currentFrameIndex++;\n    } else {\n      this.stopAnimation(); // Si ferma quando raggiunge l'ultimo frame\n    }\n  }\n  // Controlli manuali\n  nextFrame() {\n    if (this.currentFrameIndex < this.totalFrames - 1) {\n      this.currentFrameIndex++;\n      this.showFrame(this.currentFrameIndex);\n    }\n  }\n  previousFrame() {\n    if (this.currentFrameIndex > 0) {\n      this.currentFrameIndex--;\n      this.showFrame(this.currentFrameIndex);\n    }\n  }\n  goToFrame(event) {\n    const target = event.target;\n    if (target) {\n      const frameIndex = +target.value;\n      if (frameIndex >= 0 && frameIndex < this.totalFrames) {\n        this.currentFrameIndex = frameIndex;\n        this.showFrame(this.currentFrameIndex);\n      }\n    }\n  }\n  generateHeatmapCells() {\n    if (!this.currentFrame || this.currentFrame.length === 0) {\n      console.error('Invalid current frame data');\n      return;\n    }\n    this.heatmapCells = [];\n    this.currentFrame.forEach((row, rowIndex) => {\n      row.forEach((value, colIndex) => {\n        // Gestione valori non validi\n        if (value === undefined || value === null || isNaN(value) || !isFinite(value)) {\n          value = this.minValue; // O 0, oppure salta la cella\n        }\n\n        const normalizedValue = this.maxValue !== this.minValue ? (value - this.minValue) / (this.maxValue - this.minValue) : 0;\n        const color = this.getViridisColor(normalizedValue);\n        this.heatmapCells.push({\n          row: rowIndex,\n          col: colIndex,\n          value: value,\n          color: color\n        });\n      });\n    });\n    console.log(`Frame ${this.currentFrameIndex}: ${this.heatmapCells.length} cells generated`);\n  }\n  getViridisColor(normalizedValue) {\n    // Replica il colormap viridis di pyqtgraph\n    // Transizione: Viola scuro -> Blu -> Verde -> Giallo\n    if (normalizedValue <= 0.25) {\n      // Viola scuro a Blu\n      const t = normalizedValue / 0.25;\n      const r = Math.round(68 + (59 - 68) * t);\n      const g = Math.round(1 + (82 - 1) * t);\n      const b = Math.round(84 + (139 - 84) * t);\n      return `rgb(${r}, ${g}, ${b})`;\n    } else if (normalizedValue <= 0.5) {\n      // Blu a Verde scuro\n      const t = (normalizedValue - 0.25) / 0.25;\n      const r = Math.round(59 + (33 - 59) * t);\n      const g = Math.round(82 + (144 - 82) * t);\n      const b = Math.round(139 + (140 - 139) * t);\n      return `rgb(${r}, ${g}, ${b})`;\n    } else if (normalizedValue <= 0.75) {\n      // Verde scuro a Verde chiaro\n      const t = (normalizedValue - 0.5) / 0.25;\n      const r = Math.round(33 + (94 - 33) * t);\n      const g = Math.round(144 + (201 - 144) * t);\n      const b = Math.round(140 + (98 - 140) * t);\n      return `rgb(${r}, ${g}, ${b})`;\n    } else {\n      // Verde chiaro a Giallo\n      const t = (normalizedValue - 0.75) / 0.25;\n      const r = Math.round(94 + (253 - 94) * t);\n      const g = Math.round(201 + (231 - 201) * t);\n      const b = Math.round(98 + (37 - 98) * t);\n      return `rgb(${r}, ${g}, ${b})`;\n    }\n  }\n};\nDopplerRangeComponent = __decorate([Component({\n  selector: 'app-doppler-range',\n  templateUrl: './doppler-range.component.html',\n  styleUrls: ['./doppler-range.component.css']\n})], DopplerRangeComponent);","map":{"version":3,"names":["Component","DopplerRangeComponent","constructor","dataService","dopplerData","currentFrame","heatmapCells","maxValue","minValue","currentFrameIndex","totalFrames","isAnimating","animationInterval","animationSpeed","rows","cols","ngOnInit","fetchDopplerData","ngOnDestroy","stopAnimation","console","log","getDoppler","subscribe","next","data","initializeData","error","rangeData","length","originalRows","originalCols","calculateGlobalMinMax","showFrame","allValues","forEach","frame","row","push","Math","max","min","slice","frameIndex","transposeMatrix","generateHeatmapCells","matrix","transposed","j","i","startAnimation","setInterval","updateFrame","clearInterval","nextFrame","previousFrame","goToFrame","event","target","value","rowIndex","colIndex","undefined","isNaN","isFinite","normalizedValue","color","getViridisColor","col","t","r","round","g","b","__decorate","selector","templateUrl","styleUrls"],"sources":["C:\\Users\\hibab\\Desktop\\OBSIDIAN\\WLCN\\frontend\\src\\app\\components\\doppler-range\\doppler-range.component.ts"],"sourcesContent":["import { Component, OnInit, OnDestroy } from '@angular/core';\r\nimport { DataService } from '../../services/data.service';\r\n\r\ninterface DopplerData {\r\n  \"Range-Doppler Map\": number[][][]; // Array di frame, ogni frame Ã¨ una matrice 2D\r\n}\r\n\r\n@Component({\r\n  selector: 'app-doppler-range',\r\n  templateUrl: './doppler-range.component.html',\r\n  styleUrls: ['./doppler-range.component.css']\r\n})\r\nexport class DopplerRangeComponent implements OnInit, OnDestroy {\r\n  dopplerData: DopplerData | null = null;\r\n  currentFrame: number[][] = [];\r\n  heatmapCells: Array<{row: number, col: number, value: number, color: string}> = [];\r\n  maxValue: number = 0;\r\n  minValue: number = 0;\r\n  \r\n  // Animation properties (come LivePlot_class.py)\r\n  currentFrameIndex: number = 0;\r\n  totalFrames: number = 0;\r\n  isAnimating: boolean = false;\r\n  animationInterval: any = null;\r\n  animationSpeed: number = 100; // 100ms come nel LivePlot_class.py\r\n  \r\n  // Grid dimensions\r\n  rows: number = 0;\r\n  cols: number = 0;\r\n\r\n  constructor(private dataService: DataService) { }\r\n\r\n  ngOnInit(): void {\r\n    this.fetchDopplerData();\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.stopAnimation();\r\n  }\r\n\r\n  fetchDopplerData(): void {\r\n    console.log('Fetching Range-Doppler Map data...');\r\n    this.dataService.getDoppler().subscribe({\r\n      next: (data: DopplerData) => {\r\n        console.log('Range-Doppler Map data received:', data);\r\n        this.dopplerData = data;\r\n        this.initializeData();\r\n      },\r\n      error: (error) => {\r\n        console.error('Error fetching Range-Doppler data:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  private initializeData(): void {\r\n    if (!this.dopplerData || !this.dopplerData['Range-Doppler Map']) {\r\n      console.error('Invalid Range-Doppler Map data');\r\n      return;\r\n    }\r\n\r\n    const rangeData = this.dopplerData['Range-Doppler Map'];\r\n    this.totalFrames = rangeData.length;\r\n    console.log('Total frames:', this.totalFrames);\r\n    \r\n    if (this.totalFrames > 0) {\r\n      // Dimensioni originali\r\n      const originalRows = rangeData[0].length;\r\n      const originalCols = rangeData[0][0].length;\r\n      \r\n      // Dopo la trasposizione, le dimensioni si scambiano\r\n      this.rows = originalCols;  // Le colonne diventano righe\r\n      this.cols = originalRows;  // Le righe diventano colonne\r\n      \r\n      console.log('Original dimensions:', originalRows, 'x', originalCols);\r\n      console.log('Transposed dimensions:', this.rows, 'x', this.cols);\r\n      \r\n      // Calcola min/max su tutti i frame\r\n      this.calculateGlobalMinMax();\r\n      console.log('Value range:', this.minValue, 'to', this.maxValue);\r\n      \r\n      // Mostra il primo frame\r\n      this.currentFrameIndex = 0;\r\n      this.showFrame(this.currentFrameIndex);\r\n    }\r\n  }\r\n\r\n  private calculateGlobalMinMax(): void {\r\n    const allValues: number[] = [];\r\n    this.dopplerData!['Range-Doppler Map'].forEach(frame => {\r\n      frame.forEach(row => {\r\n        allValues.push(...row);\r\n      });\r\n    });\r\n    \r\n    this.maxValue = Math.max(...allValues);\r\n    this.minValue = Math.min(...allValues);\r\n    console.log('Sample values:', allValues.slice(0, 10)); // Mostra i primi 10 valori\r\n  }\r\n\r\n  private showFrame(frameIndex: number): void {\r\n    if (!this.dopplerData || frameIndex >= this.totalFrames) return;\r\n    \r\n    // Ottieni il frame originale\r\n    let frame = this.dopplerData['Range-Doppler Map'][frameIndex];\r\n    \r\n    // Applica la trasposizione per ruotare di 90 gradi\r\n    this.currentFrame = this.transposeMatrix(frame);\r\n    this.generateHeatmapCells();\r\n  }\r\n\r\n  // Funzione per trasporre una matrice (ruota di 90 gradi)\r\n  private transposeMatrix(matrix: number[][]): number[][] {\r\n    if (!matrix || matrix.length === 0) return matrix;\r\n    \r\n    const rows = matrix.length;\r\n    const cols = matrix[0].length;\r\n    const transposed: number[][] = [];\r\n    \r\n    // Crea la matrice trasposta: [i][j] diventa [j][i]\r\n    for (let j = 0; j < cols; j++) {\r\n      transposed[j] = [];\r\n      for (let i = 0; i < rows; i++) {\r\n        transposed[j][i] = matrix[i][j];\r\n      }\r\n    }\r\n    \r\n    return transposed;\r\n  }\r\n\r\n  // Metodi di controllo animazione (come LivePlot_class.py)\r\n  startAnimation(): void {\r\n    if (this.isAnimating) return;\r\n    \r\n    this.isAnimating = true;\r\n    this.currentFrameIndex = 0;\r\n    \r\n    this.animationInterval = setInterval(() => {\r\n      this.updateFrame();\r\n    }, this.animationSpeed);\r\n  }\r\n\r\n  stopAnimation(): void {\r\n    this.isAnimating = false;\r\n    if (this.animationInterval) {\r\n      clearInterval(this.animationInterval);\r\n      this.animationInterval = null;\r\n    }\r\n  }\r\n\r\n  private updateFrame(): void {\r\n    if (this.currentFrameIndex < this.totalFrames) {\r\n      this.showFrame(this.currentFrameIndex);\r\n      console.log(`Frame: ${this.currentFrameIndex}`);\r\n      this.currentFrameIndex++;\r\n    } else {\r\n      this.stopAnimation(); // Si ferma quando raggiunge l'ultimo frame\r\n    }\r\n  }\r\n\r\n  // Controlli manuali\r\n  nextFrame(): void {\r\n    if (this.currentFrameIndex < this.totalFrames - 1) {\r\n      this.currentFrameIndex++;\r\n      this.showFrame(this.currentFrameIndex);\r\n    }\r\n  }\r\n\r\n  previousFrame(): void {\r\n    if (this.currentFrameIndex > 0) {\r\n      this.currentFrameIndex--;\r\n      this.showFrame(this.currentFrameIndex);\r\n    }\r\n  }\r\n\r\n  goToFrame(event: Event): void {\r\n    const target = event.target as HTMLInputElement;\r\n    if (target) {\r\n      const frameIndex = +target.value;\r\n      if (frameIndex >= 0 && frameIndex < this.totalFrames) {\r\n        this.currentFrameIndex = frameIndex;\r\n        this.showFrame(this.currentFrameIndex);\r\n      }\r\n    }\r\n  }\r\n\r\n  private generateHeatmapCells(): void {\r\n    if (!this.currentFrame || this.currentFrame.length === 0) {\r\n      console.error('Invalid current frame data');\r\n      return;\r\n    }\r\n\r\n    this.heatmapCells = [];\r\n    \r\n    this.currentFrame.forEach((row: number[], rowIndex: number) => {\r\n      row.forEach((value: number, colIndex: number) => {\r\n        // Gestione valori non validi\r\n        if (value === undefined || value === null || isNaN(value) || !isFinite(value)) {\r\n          value = this.minValue; // O 0, oppure salta la cella\r\n        }\r\n        const normalizedValue = this.maxValue !== this.minValue \r\n          ? (value - this.minValue) / (this.maxValue - this.minValue)\r\n          : 0;\r\n        const color = this.getViridisColor(normalizedValue);\r\n        this.heatmapCells.push({\r\n          row: rowIndex,\r\n          col: colIndex,\r\n          value: value,\r\n          color: color\r\n        });\r\n      });\r\n    });\r\n    \r\n    console.log(`Frame ${this.currentFrameIndex}: ${this.heatmapCells.length} cells generated`);\r\n  }\r\n\r\n  private getViridisColor(normalizedValue: number): string {\r\n    // Replica il colormap viridis di pyqtgraph\r\n    // Transizione: Viola scuro -> Blu -> Verde -> Giallo\r\n    if (normalizedValue <= 0.25) {\r\n      // Viola scuro a Blu\r\n      const t = normalizedValue / 0.25;\r\n      const r = Math.round(68 + (59 - 68) * t);\r\n      const g = Math.round(1 + (82 - 1) * t);\r\n      const b = Math.round(84 + (139 - 84) * t);\r\n      return `rgb(${r}, ${g}, ${b})`;\r\n    } else if (normalizedValue <= 0.5) {\r\n      // Blu a Verde scuro\r\n      const t = (normalizedValue - 0.25) / 0.25;\r\n      const r = Math.round(59 + (33 - 59) * t);\r\n      const g = Math.round(82 + (144 - 82) * t);\r\n      const b = Math.round(139 + (140 - 139) * t);\r\n      return `rgb(${r}, ${g}, ${b})`;\r\n    } else if (normalizedValue <= 0.75) {\r\n      // Verde scuro a Verde chiaro\r\n      const t = (normalizedValue - 0.5) / 0.25;\r\n      const r = Math.round(33 + (94 - 33) * t);\r\n      const g = Math.round(144 + (201 - 144) * t);\r\n      const b = Math.round(140 + (98 - 140) * t);\r\n      return `rgb(${r}, ${g}, ${b})`;\r\n    } else {\r\n      // Verde chiaro a Giallo\r\n      const t = (normalizedValue - 0.75) / 0.25;\r\n      const r = Math.round(94 + (253 - 94) * t);\r\n      const g = Math.round(201 + (231 - 201) * t);\r\n      const b = Math.round(98 + (37 - 98) * t);\r\n      return `rgb(${r}, ${g}, ${b})`;\r\n    }\r\n  }\r\n}\r\n\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}